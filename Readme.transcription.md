Субтитры

## Implementing Refresh Tokens

Обновление токена - это специальный токен, используемый для получения новых доступных токенов. Это позволяет нам использовать доступные токены с коротким сроком действия без необходимости вручную входить в систему каждый раз, когда исходный доступный токен истекает. После истечения срока действия доступного токена клиентские приложения могут использовать обновляющий токен для автоматического обновления или получения нового доступного токена в фоновом режиме. Обновляющие токены должны возвращаться вместе с доступными и/или идентификаторными токенами как часть исходного процесса аутентификации и авторизации пользователя. После этого приложения должны надежно сохранять обновляющие токены. Можно представить обновляющий токен, как если бы это был набор учетных данных пользователя, так как он позволяет им повторно аутентифицироваться.

Достаточно теории, давайте перейдем к нашей IDE и начнем реализацию этой функциональности обновления токена. Сначала давайте откроем наш файл .env, чтобы объявить новую переменную окружения, которая указывает время жизни для наших обновляющих токенов. Давайте используем значение 86 400, что представляет собой 24 часа или один день, но в миллисекундах.

Затем перейдем в файл конфигурации JWT и добавим новое свойство для времени жизни обновляющего токена, следуя той же конвенции именования, которую мы использовали для доступных токенов. Мы передаем значение по умолчанию fallback, на случай если переменная окружения не установлена, но в идеале вы должны включить функцию проверки схемы. Сделаем это в основном курсе для получения дополнительной информации.

Отлично. Давайте убедимся, что мы сохраняем наши изменения и перейдем к нашей службе аутентификации. Для упрощения давайте переработаем логику подписи токена и вынесем ее в отдельный метод, называя этот метод signToken. Нам потребуется немного больше, чтобы получить то, что нам нужно. Давайте добавим несколько вещей в наш метод. Сначала начнем с модификации автоматически сгенерированной сигнатуры метода и добавим три параметра. User ID типа number, который представляет собой ID пользователя, Expires In, который представляет срок действия токена. Это будет разное значение в зависимости от того, генерируем мы доступный токен или обновляющий токен. И, наконец, Payload, который представляет собой дополнительный набор свойств, которые должны быть подписаны и встроены в токен типа T, который будет нашим типовым аргументом, который мы можем передать с помощью обобщения. После того как у нас есть сигнатура метода, давайте воспользуемся этими новыми параметрами и обновим все в теле метода для их использования. Великолепно. Наконец, давайте обновим использование метода в нашем методе sign-in выше, убедившись, что мы передаем обобщенный метод signToken с частичными активными данными пользователя и затем передаем ему три параметра. Как мы видим, теперь у нас есть доступный метод signToken, который мы можем использовать для генерации нашего обновляющего токена. Теперь нам нужно использовать promise.all, чтобы генерировать оба токена параллельно, что сэкономит нам некоторое время и обеспечит лучшую производительность. Итак, сначала преобразуем этот фрагмент в формат promise.all. Затем давайте добавим здесь также логику генерации обновляющего токена. Идеально. Наконец, нам просто нужно добавить свойство обновления токена к объекту, возвращенному из этого метода sign-in, и мы готовы. Давайте убедимся, что мы сохраняем наши изменения, перейдем в Insomnia и вызовем конечную точку sign-in, чтобы протестировать всё. Как мы видим, помимо нашего доступного токена, мы получаем новый добавленный обновляющий токен. Великолепно. Как мы можем его использовать? Существует два варианта. В первом подходе мы могли бы изменить существующую конечную точку sign-in, чтобы принимать дополнительные свойства в теле запроса, соответственно grant, который указывает, какую стратегию мы хотим использовать, токен или учетные данные. Во втором подходе мы могли бы просто добавить новую конечную точку, которая проверяет входящий обновляющий токен и генерирует пары доступных и обновляющих токенов для нас. В целях упрощения мы выберем второй подход, но помните, что есть и другие варианты для достижения этой цели. Хорошо, сначала в папке imAuthenticationDTO давайте добавим новый файл и назовем его refresh-token.dto. Внутри этого файла давайте добавим простой класс DTO и назовем его refreshTokenDTO. Давайте аннотируем свойство refreshToken аннотацией isNotEmpty из пакета class-validator. С этим внутри давайте перейдем к нашему контроллеру аутентификации и добавим соответствующую конечную точку refreshTokensPost. Аналогично нашей конечной точке sign-in, мы аннотировали ее аннотацией HTTP, чтобы указать фреймворку, что в случае успешного ответа следует использовать статус OK, также известный как 200. Давайте скопируем то, что у нас есть здесь, откроем службу аутентификации и вставим это туда, удалив все HTTP-специфичные аннотации и пометив этот метод как асинхронный. Внутри нашего метода давайте сначала проверим входящий обновляющий токен. Затем давайте используем sub, который представляет собой идентификатор пользователя, для извлечения сущности пользователя из базы данных. Как только у нас есть экземпляр пользователя, давайте прокрутимся наверх к методу sign-in, так как мы можем использовать логику генерации токенов, но мы хотим избежать копирования кода, так что давайте переработаем этот метод и извлечем эти строки в отдельный метод. Давайте назовем этот новый метод generateTokens. Прежде чем продолжить, давайте убедимся, что мы отметили этот метод как публичный, так как нам понадобится он в будущих уроках. С нашим новым методом мы можем использовать метод generateTokens в нашем недавно определенном методе refreshTokens. Наконец, давайте завернем все в блок try-catch, и в случае возникновения ошибки, будь то отсутствие пользователя, недействительный или истекший обновляющий токен и так далее, мы обязательно бросим ошибку unauthorized exception. Прекрасно. Давайте сохраним наши изменения и вернемся в Insomnia. Давайте скопируем обновляющий токен, который мы получили несколько минут назад, и вызовем конечную точку authentication/refresh-tokens, чтобы получить новую пару токенов, передав обновляющий токен в теле запроса. И вуаля! Мы успешно пересоздали наши токены, используя обновляющий токен. Как видите, пользователи теперь могут повторно аутентифицировать себя через обновляющие токены, сохраняя при этом относительно высокий уровень безопасности нашего приложения благодаря короткому времени жизни доступных токенов.


## Invalidating Tokens?

Одним из преимуществ JWT или JSON Web Tokens является их состояние "stateless" (без состояния). Это означает, что нам не нужно обращаться к центральной базе данных для проверки токена при каждом входящем запросе. Пока подпись токена действительна, и сам токен не истек, мы можем аутентифицировать запрос и связать его с соответствующим пользователем. Однако это представляет определенные сложности. Предположим, мы хотим отменить утечку или компрометацию токена обновления, чтобы предотвратить вход злоумышленника в нашу систему. Или предположим, что администратор обновил роль или разрешения пользователя, и его сеанс должен автоматически завершиться, если роли пользователя были встроены в токен. Как же мы можем решить эти проблемы?

Ну, так как наши текущие токены не сохраняются в базе данных, так как они "stateless", мы не можем их отозвать, если только не удалим пользователя. Но это обычно не то, что нам нужно делать. Что, если мы сохраняем токены в базе данных? С этим подходом мы могли бы проверить, какие токены действительны, а какие нужно аннулировать, основываясь на их наличии в базе данных или отсутствии там. Но это делает JWT "stateful" (со состоянием) и схожими по поведению с учетными данными. Фактически, чтобы сделать эту идею работающей, нам пришлось бы хранить список всех выданных токенов в отдельной таблице или в существующей таблице пользователей. Затем сторож, который мы реализовали, должен был бы запросить базу данных при каждом входящем запросе, чтобы проверить, включен ли данный токен в список сохраненных токенов. Вы можете представить, что это повлияло бы на производительность нашего приложения негативно. Таким образом, этот подход не является идеальным. В этом уроке мы продемонстрируем что-то, что мы считаем хорошей промежуточной решающей границей.

Сначала мы реализуем механизм, называемый "поворотом токена обновления". Когда токен обновления использовался для выдачи новой пары токенов, мы аннулируем исходный или старый токен обновления, чтобы он больше не мог быть использован в будущем. Для этого мы собираемся добавить базу данных Redis в наш стек, но вы можете использовать любую базу данных, которую захотите. Вы даже можете воспользоваться нашей существующей базой данных Postgres и просто добавить отдельную таблицу, если это удобнее. Мы решили использовать Redis, потому что это легковесная система хранения ключ-значение, которая обеспечивает отличную производительность, и именно то, что нам нужно для выполнения поставленной задачи. Давайте перейдем к нашей среде разработки и откроем файл Docker Compose, а затем добавим в него службу Redis. Далее давайте установим пакет io-redis, который является надежным клиентом Redis. Откроем терминал и выполним команду npm i io-redis.

Давайте также убедимся, что мы запускаем нашу новую службу Redis с помощью команды docker-compose-up-d. Затем давайте сгенерируем класс хранилища refresh-token-ids с помощью следующей команды. nest g class im slash authentication slash refresh-token-ids.storage. После создания класса давайте перейдем в модуль im и зарегистрируем хранилище refresh-token-ids как провайдера. Теперь перейдем к самому классу хранилища refresh-tokens-ids. Сначала давайте пометим его декоратором injectable, как всегда. Далее давайте реализуем два интерфейса, которые позволят нам подключиться к событиям жизненного цикла приложения Nest. Это события on-application bootstrap и on-application shutdown.

Наша среда разработки подскажет нам, что нам нужно реализовать эти интерфейсы. Давайте сделаем это. Внутри метода on-application bootstrap добавим следующий код, который вы можете найти ниже видеоурока. Как видите в этом комментарии, в идеале нам следовало бы зарегистрировать отдельный модуль Redis, который инкапсулирует клиент Redis и привязывается к жизненному циклу приложения. Однако в этом курсе мы хотим в основном сосредоточиться на аутентификации и авторизации, поэтому мы решили сделать здесь упрощение, так как не хотим тратить слишком много времени на вещи, которые мы уже рассмотрели в курсе основ. Не волнуйтесь, этот подход все рав


## Role-Based Access Control

Авторизация, часто путаютая или объединяемая с концепцией аутентификации, которую мы обсуждали в этом курсе, - это процесс предоставления пользователю разрешения на доступ к конкретным ресурсам или функциям. Например, административному пользователю разрешено создавать, редактировать и удалять кофе, в то время как обычному пользователю разрешено только просматривать кофе. Авторизация является ортогональной, что означает, что она независима от аутентификации. Однако, как мы уже упомянули в предыдущих уроках, авторизация требует механизма аутентификации, который, к счастью, мы уже реализовали. Управление доступом на основе ролей, или RBAC, является механизмом управления доступом, нейтральным к политике, определенным вокруг ролей и привилегий. При использовании управления доступом на основе ролей вы анализируете потребности ваших пользователей и группируете их в определенные роли на основе общих обязанностей. Например, предположим, у нас есть приложение для каталога кофе. Пользователи с ролью администратора могут управлять кофе, добавлять, редактировать или удалять их из каталога. С другой стороны, обычные пользователи могут только просматривать список кофе и просматривать отдельные кофе. У нас даже может быть роль наблюдателя или супер-администратора, которая, помимо управления кофе, может создавать, редактировать и удалять существующих пользователей, включая тех, у которых есть роль администратора. Они могут даже иметь возможность повышать пользователя из обычного пользователя до администратора. Суть роли - это набор разрешений, которые можно применить к пользователям. Использование ролей упрощает добавление, удаление и настройку разрешений, в отличие от присвоения разрешений каждому пользователю индивидуально. В этом уроке мы определим перечисление ролей, которое будет представлять все роли, поддерживаемые в нашем проекте. В нашем случае мы просто создадим статические значения, которые не берутся из базы данных или чего-либо еще. Но в некоторых ситуациях мы бы хотели хранить эти роли в базе данных, а еще лучше, возможно, мы бы хотели иметь панель управления, где мы могли бы создавать новые роли и назначать их существующим пользователям. Если вы хотите, вы можете создать новый ресурс ролей, используя NestJS CLI, реализовать конечные точки CRUD, объявить сущность роли, установить отношение между пользователем и сущностью роли и т. Д. Но так как все это выходит за рамки данного расширения, мы продолжим с предопределенным и статическим списком ролей. Итак, вернемся к нашему коду, давайте перейдем к нашей среде разработки и начнем с добавления нового каталога внутри каталога пользователей и назовем его enums. Внутри этой папки создадим новое перечисление с именем role.enum.ts. В этом файле давайте объявим следующее статическое перечисление, которое мы будем использовать. Это перечисление состоит из двух значений: regular, которое представляет собой обычного пользователя, и admin, что указывает на то, что пользователь способен управлять кофе. Как мы уже упоминали ранее, в зависимости от того, какое приложение вы собираетесь создавать, вы можете добавлять больше и другие роли в это перечисление. Как уже упоминалось, возможно, вы бы хотели бы, чтобы они хранились в базе данных. Далее давайте откроем класс сущности пользователя и добавим там новый столбец role. Отлично. Здесь есть один момент: нашему существующему пользователю не назначена роль, так как он был создан до того, как мы ввели этот столбец. Давайте обновим всех наших пользователей с помощью новой функции REPL Nests. REPL - это простое интерактивное окружение, которое принимает ввод пользователей, выполняет его и возвращает результат обратно. Функция REPL позволяет вам проверить граф зависимостей и вызывать методы на ваших провайдерах и контроллерах непосредственно из вашего терминала. Обратите внимание, что мы используем функцию REPL здесь в основном для удобства использования, так как мы изучаем новые концепции и имеем дело с нашими службами и базой данных в этом курсе, но вы не захотите использовать это в любом производственном окружении и тому подобное. Это отличная опция только во врем


## Claims-based Authorization

Заявка - это пара имя-значение, представляющая, что субъект может делать, а не то, что субъект является.
При реализации авторизации на основе заявок, вместо определения набора ролей, которые могут быть назначены пользователям, мы определяем несколько разрешений и затем имеем возможность назначать эти разрешения отдельным пользователям.
В нашем приложении до сих пор мы предполагаем, что только пользователи с ролью администратора могут создавать, обновлять и удалять кофе.
Авторизация на основе заявок пригодится, когда нам нужен более детализированный контроль и, например, мы хотим, чтобы конкретные пользователи могли создавать и обновлять кофе, но только один конкретный супервизор может удалять кофе.
Давайте переключимся на нашу среду разработки и начнем с создания нового файла coffees.permission.ts в каталоге coffees.
Внутри этого файла создадим перечисление, представляющее все разрешения, связанные с кофе.
Вы можете найти код ниже видео курса.
Обратите внимание, что обычно эти разрешения хранятся в отдельной базе данных.
Теперь создадим декоратор для разрешений, который указывает, какие разрешения требуются для доступа к аннотированной конечной точке.
Как и в предыдущих уроках, мы будем следовать тому же синтаксису для создания нашего декоратора разрешений.
Код можно найти ниже видео курса.
Теперь создадим стражу для разрешений.
И, как и в нашей страже для ролей, она практически идентична, поэтому нам не нужно рассматривать каждую строку здесь.
Обратите внимание, что единственное основное отличие здесь заключается в том, что мы извлекаем ключи разрешений и проверяем разрешения пользователя по сравнению с тем, что было передано в декоратор.
Еще одной важной разницей в нашей проверке разрешений здесь по сравнению с нашей стражей ролей является то, что вместо использования метода sum, мы хотим использовать метод every, который обеспечивает, что у пользователя есть все необходимые разрешения, а не только одно из них.
Кроме того, так как у пользователей может быть несколько разрешений, вместо тройного равенства мы используем метод includes.
И все, с нашей стражей разрешений все готово, давайте теперь откроем модуль IAM и временно заменим стражу ролей нашей стражей разрешений, чтобы упростить вещи ради этого урока.
Хорошо, теперь единственным оставшимся шагом является добавление отсутствующего столбца разрешений в сущность пользователей.
Откроем его и добавим его сразу под существующим столбцом ролей.
Обратите внимание, как мы уже упоминали ранее, в приложении реального мира, вероятно, у вас будет отдельная таблица разрешений, в которой будут храниться разрешения, специфичные для приложения.
Также, вместо хранения разрешений пользователей в столбце JSON, будет существовать отношение многие ко многим между пользователями и таблицей разрешений.
Как и в прошлом уроке, если вы хотите попрактиковаться, вы можете создать сущность, контроллеры, связи и т. д., чтобы все это установить, если хотите.
Еще одним распространенным подходом к разрешениям является связывание разрешений с самими ролями.
Это немного другой метод и требует другой конфигурации, но может быть более подходящим для некоторых систем.
В этом другом подходе вы можете продолжать использовать ролевой контроль доступа с ролями, и каждая роль должна указывать свой набор разрешений, связанных с ней.
Возвращаясь к нашему коду, как вы видите в комментарии выше столбца разрешений, наличие этого столбца в сочетании с ролью не имеет смысла.
Мы используем оба в этом курсе, чтобы продемонстрировать два разных подхода к авторизации, но в вашем приложении вы должны решить, какой подход вы выберете.
Хорошо, следующим шагом давайте откроем наш интерфейс активных пользовательских данных и добавим соответствующее поле разрешений.
И наконец, но не менее важно, нам нужно снова открыть службу аутентификации и убедиться, что мы включили поле разрешений в асинхронный токен.
Обратите внимание, что и в этот раз это далеко не идеально.
Вставка большого массива строк в наш токен приведет к длинному, не легковесному токену.
В реальном приложении, где разрешения хранятся в базе данных, вам следует включать здесь только массив идентификаторов.
Более того, если вы ожидаете много разрешений в вашей системе, возможно, вам вообще не следует вставлять их в токен.
В большинстве случаев мы хотели бы иметь их в базе данных, и мы бы извлекали эти разрешения при каждом действии или запросе.
Хорошо, с этим столбцом все готово, давайте сохраните наши изменения, откроем файл контроллера кофе и вместо использования декоратора ролей поверх нашего метода создания давайте используем теперь разрешения, передавая permission.createcoffee как входной аргумент.
Сохраните наши изменения, перейдите в Insomnia и начнем с того, что сначала получим новый токен доступа.
Получив ответ, обновите заголовок авторизации с вновь полученным токеном доступа и перейдите к конечной точке кофе.
Отлично!
Мы получили ошибку 403 Запрещено, как и следовало ожидать, так как нашему пользователю еще не назначены какие-либо разрешения.
Чтобы исправить это, давайте вернемся к нашей среде разработки, откроем наши терминалы и снова используем REPL, чтобы добавить разрешение на создание кофе для нашего пользователя.
Обратите внимание, что если у вас возникают ошибки, такие как свойство permissions не найдено в пользователе, вам может потребоваться перезапустить сеанс REPL, то есть закрыть окно и запустить его снова.
Давайте получим репозиторий пользователя, обновим пользователя one и добавим разрешение на создание кофе.
Отлично!
Теперь вернемся к Insomnia, давайте снова получим новый токен, убедившись, что эти обновленные разрешения в него внедрены.
Давайте возьмем токен и обновим этот заголовок авторизации в последний раз и отправим конечную точку coffee's post снова.
Мы видим, что все работает!
Наша система разрешений настроена и работает правильно.
Как мы упомянули в этом уроке, существует множество различных методов и подходов к авторизации на основе заявок и ролевому управлению доступом.
Здесь в этом уроке у нас есть и то и другое, так как мы построили на основе того же проекта, что и в предыдущем уроке, но в реальном приложении вам, вероятно, понадобится только один или немного другой вариант, как мы кратко упомянули только что, где разрешения связаны с самими ролями, а не непосредственно с пользователями.


## Policy-based Authorization

Политика определяет требование или совокупность требований, которые пользователь должен удовлетворить, чтобы получить доступ к ресурсу.
Фактически, даже если вы используете авторизацию на основе заявок или ролей, на самом деле вы используете авторизацию на основе политики, но как жестко закодированные политики.
Подумайте о декораторе ролей, который мы создали, который требовал, чтобы у пользователя была определенная роль, по сути создавая жестко закодированную политику, реализованную внутри нашей стражи ролей.
Просто как отмазка, что в этом уроке мы рассмотрим некоторые более сложные сценарии авторизации, которые обычно не требуются для большинства приложений.
Обычно достаточно авторизации на основе ролей или на основе заявок, но мы подумали, что может быть полезно продемонстрировать авторизацию на основе политики, на всякий случай, если вам это понадобится в будущих приложениях.
Хорошо, перейдем к нашей среде разработки и посмотрим, как мы могли бы использовать политики в нашем приложении, если бы мы почувствовали, что они нам нужны.
Внутри каталога авторизации создадим следующее дерево каталогов: policies/interfaces.
В папке interfaces создадим новый файл и назовем его policy.interface.ts.
Внутри этого файла объявим интерфейс политики.
Это будет очень простой интерфейс, состоящий из одного свойства, name, которое мы будем использовать, чтобы упростить отладку.
Далее создадим еще один файл рядом с интерфейсом политики и назовем его policy-handler.ts.
Внутри этого файла объявим интерфейс обработчика политики.
Этот интерфейс требует, чтобы метод handle был реализован.
Этот метод handle будет принимать два аргумента: policy, который представляет собой соответствующий экземпляр политики, для которой этот обработчик был реализован.
Обратите внимание на обобщенный тип T, так как у разных обработчиков политики могут быть собственные политики.
И второй аргумент - объект активных пользовательских данных, указывающий, кто является контекстным пользователем, для которого мы выполняем эту политику.
Отлично.
С этими интерфейсами на месте, перейдем к классу хранения обработчиков политики.
Этот класс будет служить нам как статическая коллекция map, связывающая политики с соответствующими обработчиками политики.
Каждая политика должна иметь ровно один обработчик политики.
Обработчик политики будет отвечать за обработку конкретной политики.
Не волнуйтесь, все это станет более понятным через момент.
Давайте начнем с создания файла policy-handlers.storage в нашем каталоге политик и внутри этого файла объявим простой класс, который содержит одну закрытую коллекцию.
Также убедимся, что он аннотирован декоратором injectable.
Первый аргумент типа, который мы указываем для класса map, указывает тип наших ключей в этой коллекции.
Поскольку ключи представляют собой классы, представляющие наши политики, мы должны использовать тип policy здесь.
Второй аргумент типа, который мы видим здесь, представляет значения для этих ключей.
Здесь мы использовали обработчик политики типа any, так как мы будем использовать экземпляры обработчика политики в качестве значений.
Обратите внимание, что в случае ключей мы работаем с типами, а не с конкретными экземплярами, так как мы хотим позволить разработчикам вручную создавать и настраивать политики, например, если разные конечные точки в нашем приложении имеют разные требования.
Хорошо, достаточно теории, далее нам понадобятся два метода, которые позволяют нам работать с внутренней коллекцией этого класса хранения: get, для получения класса обработчика политики на основе данного класса политики, и метод add, для связывания политик с обработчиками политики.
Обратите внимание, что мы использовали суффикс cls здесь, чтобы указать, что мы работаем с классами, а не с экземплярами.
С этим классом хранения на месте мы можем начать создавать нашу первую политику.
Для демонстрационных целей мы реализуем очень настраиваемую политику - политику участника фреймворка, которая проверяет, зарегистрирован ли адрес электронной почты пользователя в домене nestjs.com.
Итак, внутри нашего каталога политик создадим новый файл и назовем его framework-contributor.policy.ts.
Внутри этого файла создадим простой класс с именем framework contributor policy и заставим его реализовать интерфейс политики.
Также не забудем указать имя этой политики.
Обратите внимание, что обычно мы рекомендуем создать еще один файл рядом с этим и назвать его framework-contributor-policy-handler.ts, но поскольку политика участника фреймворка очень проста, коротка и проста, чтобы облегчить понимание, мы решили создать обработчик прямо внутри этого файла сразу после определения политики.
Итак, давайте перейдем к созданию обработчика политики участника фреймворка сейчас.
Еще раз убедимся, что он аннотирован декоратором injectable и что он реализует наш интерфейс обработчика политики.
Затем объявим конструктор и внедрим провайдер хранилища обработчиков политики.
Внутри этого конструктора, используя метод add хранилища обработчиков политики, который мы создали немного ранее, свяжем этот обработчик соответствующей политикой участника фреймворка следующим образом.
Поскольку все наши обработчики политики предназначены для работы асинхронно, давайте пометим этот метод как async.
И отсюда мы можем начать реализовывать нашу фактическую политику.
Внутри метода handle добавим следующую логику, которую вы можете найти ниже видеоряда курса.
В коде, показанном здесь, мы просто проверяем, заканчивается ли адрес электронной почты пользователя на nestjs.com, и если нет, то выбрасываем исключение.
И все. Помните, что мы создаем очень простую политику только для демонстрационных целей, но, надеюсь, вы видите возможности здесь и понимаете, почему такой тип авторизации может быть полезен в определенных приложениях и обстоятельствах.
Прежде чем мы продолжим, давайте откроем файл immodule и убедимся, что мы зарегистрировали как провайдеры как хранилище обработчиков политики, так и класс обработчика политики участника фреймворка.
Вот почему мы добавили эти декораторы injectable.
Отлично.
Теперь есть еще два шага, которые нам нужно сделать и которые мы уже рассмотрели в предыдущих уроках.
Во-первых, внутри нашего каталога декораторов создадим новый декоратор policies для прикрепления политик к конечным точкам или контроллерам.
Как обычно, весь код для этого можно найти ниже видеоряда курса.
Как только мы закончим, создадим новую стражу policies, которая выполняет политики, специфичные для контекста, для данной операции.
Мы начнем с вставки нашей обычной заготовки, чтения метаданных, игнорирования стражи, если политики отсутствуют и так далее.
Мы уже делали это несколько раз в этом курсе.
И с этим кодом на месте, давайте начнем реализовывать логику, специфичную для политики сейчас.
Теперь давайте внедрим хранилище обработчиков политики, которое мы создали, так как нам понадобится оно для получения самих обработчиков политики.
Если политики определены, то давайте переберем их, сопоставив их с соответствующими экземплярами обработчиков политики и вызовем метод обработчика, передавая экземпляр политики в качестве первого параметра и активные пользовательские данные в качестве второго параметра.
Обратите внимание, что для получения соответствующего обработчика нам нужно передать ссылку на конструктор политики.
Как вы помните, наше хранилище обработчиков политики связывает обработчики с классами политики, а не с экземплярами.
Поскольку методы handle наших обработчиков политики асинхронны, давайте используем здесь promise.all, чтобы дождаться результатов.
И в случае возникновения ошибки, давайте используем catch и отобразим ошибки как ошибку запрета.
Отлично!
Со всем этим на месте, давайте перейдем к файлу модуля im и заменим стражу разрешений на нашу новую стражу политики.
Затем откроем файл контроллера кофе, и вместо использования декоратора разрешений давайте закомментируем его и используем аннотацию политик, применяя политику участника фреймворка.
Здорово!
Обратите внимание, что вы можете применить несколько политик к одной конечной точке, как показано ниже, если это необходимо.
Хорошо, давайте сохраните наши изменения, перейдем к программе Insomnia и протестируем все, чтобы увидеть эти политики в действии.
Давайте нажмем "Отправить" и проверим, можем ли мы получить доступ к конечной точке POST /coffees.
Обратите внимание, что если вы получаете ошибку 401, убедитесь, что вы снова вошли в систему и обновили свой токен доступа.
И да, мы видим, что у нас есть доступ, поскольку адрес электронной почты нашего пользователя - user1 at nestjs.com.
Теперь вернемся к нашей среде разработки, откроем класс обработчика политики участника фреймворка, чтобы вместо проверки наличия nestjs.com ожидать trilon.io.
Сохраните наши изменения, перейдите к Insomnia и попробуйте еще раз нажать на ту же конечную точку.
И, как видите, у нас теперь нет разрешения на доступ к этой конечной точке из-за ограничений авторизации политики, которые мы установили для нее.
Мы рассмотрели многое в этом уроке, и, надеюсь, вы видите ценность авторизации на основе политики, а также то, как она действительно может быть необходима не в каждом приложении и особенно не в каждой конечной точке.
Как и в большинстве инструментов, есть случаи использования для всего.
И с тем, что мы рассмотрели в этом уроке, вы сможете покрыть даже самые сложные сценарии авторизации в ваших будущих приложениях Nest.


## Introduction to API Keys

API-ключ - это уникальный идентификатор, используемый для подключения к API или выполнения вызова API.
API-ключи можно использовать либо для доступа к вашему приложению без какой-либо основной идентификации, либо для создания вторичных учетных данных, чтобы вы могли отправлять запросы от имени конкретного пользователя.
В первом подходе API-ключи будут полезны для анонимного доступа к общедоступным данным и будут использоваться для связывания запросов API с вашим проектом.
Во втором подходе API-ключи будут представлять собой вторичные учетные данные пользователей, у которых есть такие же или более низкие права доступа, в зависимости от заданной области.
Эти два варианта не предполагается использовать взаимозаменяемо.
Очень многое зависит от того, какое приложение вам нужно создать.
Например, если вы создаете продукт SaaS, где клиенты могут создавать собственные проекты, и вы хотели бы предоставить механизм, который позволяет пользователям взаимодействовать с этими проектами от имени стороннего инструмента анонимно, то вероятно, вам следует выбрать первый вариант, в котором API-ключи могут использоваться без какого-либо принципала и просто связаны с конкретными проектами.
Однако, если вы создаете приложение социальной сети или, допустим, что-то подобное GitHub, может быть полезно разрешить пользователям создавать собственные API-ключи, которые позволят им создавать пользовательские приложения, взаимодействующие с API вашего приложения, но без использования вашего клиентского приложения.
Фактически, пользователь может создать API-ключ, который можно использовать из стороннего инструмента, что позволит им получать доступ к информации, специфичной для пользователя, или выполнять действия от его имени.
Такой API-ключ может иметь определенный набор областей, и пользователь может управлять тем, что именно можно получить доступ к этому конкретному API-ключу.
Если вы работали с GitHub, Stripe или другими SDK, предоставляющими API-ключи, все это должно звучать знакомо, но если нет, не волнуйтесь, мы подробно рассмотрим все в следующих уроках, и вскоре все это станет понятным.
В следующих нескольких уроках мы выбираем реализацию второго варианта, так как у нас уже есть сущность пользователя, но будьте в курсе, что реализация первого подхода должна быть практически идентичной тому, что мы собираемся делать, поэтому не волнуйтесь, если вас интересует реализация или изучение первого подхода.


## Integrate API Keys feature

Как мы упомянули в предыдущем уроке, в этой главе мы реализуем функцию API-ключей, которая позволит нам отправлять запросы от имени пользователя. Давайте начнем с создания нового класса сущности под названием API-key.entity и поместим его в каталог users/API-keys/entities. Напомним, что мы передаем флаг no spec, чтобы инструмент командной строки не генерировал файлы тестов, так как они не нужны для сущностей. Давайте сделаем то, что обычно делаем, и начнем с переименования класса просто в API-key, удалив суффикс entity, так как он избыточен, и мы не хотим видеть слово "entity" в нашей базе данных. Затем давайте добавим декоратор entity сверху, убедившись, что мы импортируем его из TypeORM. И после этого добавим несколько столбцов: ID, key, UUID. Наконец, давайте установим отношение многие-к-одному с сущностью пользователя, используя декоратор many-to-one. Теперь, когда мы настроили основы нашей сущности, давайте зарегистрируем эту сущность API-key в нашем приложении. Для этого откроем модуль пользователей и добавим сущность API-key в массив импортов TypeORM модуля функций. Не забудьте обновить также сущность пользователя, добавив туда поле API-keys и указав, что пользователь - это владелец этого отношения один-ко-многим. Идеально. После обновления наших сущностей создадим новую службу API-keys в каталоге authentification. Как только она будет создана, откроем новый сгенерированный файл и определим четыре метода: createAndHash, createAndHash - для создания и хеширования новых API-ключей, validate - для проверки API-ключей, extractIdFromAPIKey - для извлечения ID из API-ключа для получения ID API-ключа из закодированного API-ключа, и, наконец, generateAPIKey - для генерации строк API-ключей. Прежде чем мы перейдем к этим методам, давайте начнем с объявления отсутствующего интерфейса payload для сгенерированного API-ключа прямо перед классом службы API-keys, хотя лучше было бы поместить это в собственный файл. Этот интерфейс будет состоять из двух свойств: API-key, которое представляет дружественный пользовательский API-ключ, и hashed-key, хешированная версия API-ключа, которую мы будем хранить в базе данных. С этим интерфейсом на месте давайте внедрим службу хеширования в конструктор службы API-keys. Теперь перейдем к методам. Мы начнем с generateAPIKey. Внутри этого метода давайте сначала сгенерируем случайную уникальную строку API-ключа с использованием функции randomUUID из нативного пакета crypto, который мы использовали в предыдущих уроках, и добавим ей префикс API-key, который в нашем случае равен ID. Затем давайте используем buffer и его метод toString для генерации соответствующей строки в формате base64, чтобы убедиться, что она выглядит более дружелюбно для пользователя и согласованно, без пробелов и т.д., и затем вернем результат. Далее давайте перейдем к методу createAndHash. Внутри начнем с генерации API-ключа с использованием метода generateAPIKey, который мы только что определили. Затем, используя службу хеширования, давайте сгенерируем хешированный ключ и дождемся результата. Наконец, давайте убедимся, что мы возвращаем сгенерированный объект payload API-ключа, то есть API-key и hashed-key. Обратите внимание, что вместо использования алгоритма bcrypt здесь можно рассмотреть что-то более производительное, так как нам придется проверять хэш для каждого запроса. UUID сам по себе уже довольно длинный, поэтому bcrypt может быть не обязателен здесь. Далее переходим к методу validate. В нашем методе validate мы просто вызовем соответствующий метод службы хеширования следующим образом и убедимся, что мы возвращаем результат. Наконец, метод extractIdFromAPIKey. Этот метод принимает закодированный API-ключ в формате base64 и возвращает извлеченный ID, который мы назначили в качестве префикса случайной уникальной строки в нашем методе generateAPIKey. Со всеми этими настройками давайте теперь создадим новый API-key guard с использованием схемы nest.js, чтобы связать все вместе. Откроем терминалы и выполним nest.gguard им/ аутентификация.им/ аутентификация / охранники / API-ключ. Теперь перейдем в этот вновь созданный файл и начнем с извлечения объекта запроса из контекста выполнения. Затем давайте определим метод extractKeyFromHeader, который вам может показаться знакомым, так как он напоминает соответствующий метод extractTokenFromHeader, который мы реализовали в нашем охраннике токена доступа. Как видите, в стратегиях, использующих токен доступа и API-ключ, мы используем заголовок авторизации. Поэтому, чтобы избежать лишних проверок, если заголовок запроса содержит токен доступа, а не API-ключ, мы добавим дополнительное условие if, которое будет возвращать переменную token только в случае, если тип равен API-ключ. Также давайте откроем охранник токена доступа и убедимся, что внесли там такое же обновление. Есть небольшое различие: вместо поиска префикса API-ключа мы теперь проверяем наличие строки bear. Отлично, вернемся к охраннику API-ключа. Давайте используем этот метод внутри метода canActivate, чтобы извлечь API-ключ, и если он не определен, давайте бросим исключение unauthorized. Прежде чем продолжить, давайте внедрим службу API-key в конструктор охранника, чтобы мы могли использовать ее для проверки входящих API-ключей. Также давайте внедрим репозиторий API-keys, чтобы мы могли получать записи API-ключей из таблицы базы данных. После наличия этих зависимостей давайте снова вернемся к методу canActivate. Используя метод extractIdFromAPIKey из нашей службы API-keys, давайте извлечем идентификатор API-ключа из закодированной строки. Затем добавим блоки try catch. Внутри блока try давайте получим сущность API-key из таблицы API-keys, используя извлеченный из закодированной строки ID. Обратите внимание, что мы указываем ORM здесь автоматически заполнять связанную сущность пользователя в рамках того же запроса. Помните, что мы используем TypeORM в этом курсе, но какой бы ORM вы ни использовали в вашем приложении, вам следует убедиться, что вы также заполняете сущность пользователя в этом вызове. Далее давайте использовать метод validate службы API-keys, чтобы проверить данный API-ключ и сравнить его с его хэшем, который мы храним в базе данных. Наконец, так как мы хотим разрешить использование API-ключей для аутентификации от имени конкретных пользователей, давайте убедимся, что мы также присваиваем связанную сущность пользователя объекту запроса, чтобы ее можно было получить позже в методах нашего контроллера. Это позволит нам легко получать доступ к пользователю в нашем коде, когда поступит запрос. Идеально, с нашим охранником все настроено, давайте откроем охранник аутентификации и внедрим в него только что созданный охранник API-ключа. Затем перейдем к перечислению auth type enum и добавим туда API-ключ. Вернемся к охраннику аутентификации и также обновим наше сопоставление, объект auth type guard map. Вот и все. Чтобы завершить, давайте откроем наш модуль IAM и внесем в него несколько изменений. Во-первых, давайте убедимся, что мы регистрируем репозиторий API-key в контексте этого модуля, добавив сущность API-key в массив импортов функций TypeORM модуля. Затем добавим охранник API-key в массив поставщиков, чтобы он мог быть внедрен, что означает, что его можно будет внедрить в охранник аутентификации. Отлично, наша аутентификация на основе API-ключей теперь настроена. Сохраним наши изменения и перейдем к контроллеру Coffee's. Здесь мы применим декоратор auth к классу контроллера, указав нашему охраннику аутентификации, что поддерживаются как стратегии с биржевыми токенами, так и стратегии, основанные на API-ключах, для маршрутов Coffee's. Хорошо, чтобы протестировать все это, нам нужно создать тестовый API-ключ. Мы не планируем реализовывать полный рабочий процесс CRUD для API-ключей, так как это мы уже подробно рассмотрели в нашем курсе по основам. Но в идеале, возможно, это то, что вы хотели бы иметь в реальном приложении. Если вы хотите, настроьте его для удовольствия и практики. Вместо этого, как более простой способ для нас проверить все, мы будем использовать функцию REPL в Nest. Давайте откроем наши терминалы и запустим REPL с использованием следующей команды: npm run start -- --entry-file и REPL. Внутри сессии REPL давайте сначала объявим уникальный ID для нашего API-ключа: UUID = строка случайный_уникальный_ID. Затем давайте дождемся и получим службу API-key, вызовем метод createAndHash для создания полезной нагрузки API-ключа и сохраним все в переменной payload. И, наконец, давайте вставим новый API-ключ в таблицу базы данных, используя репозиторий API-keys и вызов save, убедившись, что мы передаем UUID, добавляем ключ со значением payload.hashed key и пользователя, указывая пользователя с ID один. И вот, это сработало. Давайте убедимся, что мы скопировали этот сгенерированный API-ключ, который мы получили в ответ. Теперь давайте перейдем в Insomnia. И пока мы находимся на странице точки доступа Coffee's, перейдем на вкладку заголовков и заменим текущее значение заголовка авторизации на API-ключ, убедившись, что мы добавляем пробел, а затем вставим этот сгенерированный API-ключ здесь. Теперь давайте нажмем отправить и посмотрим на это. Как мы видим, запрос прошел успешно. Наш API вернул ответ нам. Мы были аутентифицированы для доступа к этой точке доступа от имени пользователя один, с проверенным API-ключом. Фантастически. Давайте вернемся в нашу IDE и посмотрим на наши терминалы. Как мы видим здесь, наш пользователь с ID один, связанный с API-ключом, был включен в консоль, благодаря console log, который мы добавили в наш контроллер Coffee's в предыдущих уроках. Со всем, что мы достигли в этом уроке, теперь наша точка доступа Coffee's поддерживает как биржевые токены, так и потоки аутентификации на основе API-ключей. Вы можете видеть, что у нашего приложения теперь есть множество возможностей. Мы теперь можем предоставить этот поток аутентификации на основе API-ключей другим частям нашего приложения, если это когда-нибудь потребуется.


## Google Authentication - NestJS portion

В этом уроке мы собираемся реализовать новую функцию, которая позволит пользователям регистрироваться и входить в наше приложение, используя свои учетные записи Google, вместо обычных учетных данных, таких как адрес электронной почты и пароль.

Для большинства приложений и тех, кто хочет удовлетворить потребности пользователей, очень важно предоставлять опции одноразовой аутентификации, такие как Google Auth, чтобы упростить регистрацию и вход в приложение.

В этом уроке мы настроим все в нашем приложении Nest. Также убедитесь, что вы просмотрели два предыдущих текстовых урока, так как они являются спутниками всего, что мы будем делать здесь. Один урок посвящен инструкциям по настройке нового проекта Google через панель управления GCP, и другой урок - тестированию нашего потока аутентификации Google.

В конечном итоге нам понадобится пользовательский интерфейс для этого, поэтому обязательно посмотрите урок о создании демонстрационного интерфейса Google Auth, где вы сможете настроить очень базовое приложение React, чтобы протестировать все. Но обратите внимание, что это можно сделать с использованием любой фронтенд-структуры на ваш выбор, мобильного приложения и т. д.

Итак, вернемся к нашей задаче, давайте переключимся на нашу среду разработки и начнем с обновления нашего файла .env. Внутри файла .env давайте объявим две новые переменные окружения: Google Client ID и Google Client Secret. Вы можете получить эти идентификаторы из вашей панели управления GCP, если вы уже настроили всё это. В противном случае убедитесь, что вы сначала пройдете оба эти текстовых урока, прежде чем продолжить дальше в этом уроке.

Затем давайте откроем наши терминалы и сначала установим новую зависимость, которую нам нужно использовать для проверки токенов Google - это пакет Google Auth library.

После завершения процесса установки давайте сгенерируем новую службу и поместим ее в каталог im/authentication/social и назовем ее Google Authentication Service. Также создадим соответствующий контроллер в этом же месте.

Отлично, давайте откроем нашу только что созданную службу аутентификации Google и объявим приватное свойство OAuthClient типа OAuth2Client, импортированное из библиотеки Google Auth, которую мы только что установили.

Теперь давайте внедрим три зависимости в конструктор нашей службы: config service, authentication service и репозиторий пользователей.

Также давайте реализуем интерфейс onModuleInit, так как мы собираемся сделать несколько вещей при инициализации модуля в жизненном цикле нашего приложения.

Внутри метода onModuleInit давайте инициализируем OAuthClient, вызвав new OAuth2Client, передавая как аргументы наш Client ID и Client Secret, которые мы можем получить из нашего файла .env.

Отлично. Далее давайте определим метод authenticate, который будет выполнять всю тяжелую работу здесь. Этот метод принимает один параметр - это токен доступа, выданный Google.

С помощью OAuthClient давайте извлечем информацию, специфичную для пользователя, следующим образом.

Теперь, прежде чем двигаться дальше, давайте быстро перейдем в класс UserEntity и также внесем два изменения. Сначала нам понадобится новый столбец с именем Google ID, который будет содержать значения только в том случае, если учетная запись пользователя связана с соответствующей учетной записью Google. Также убедимся, что мы обновим столбец пароля и сделаем его nullable, так как пользователи, использующие Google для входа, не будут иметь паролей в стандартном смысле.

Хорошо, вернемся к нашей службе аутентификации Google. Давайте извлечем сущность UserEntity на основе Google ID пользователя. Если ее еще нет, мы создадим новую учетную запись в нашей системе, в противном случае мы войдем пользователя и ответим парами токенов доступа и обновления.

Наконец, давайте обернем все в блок try-catch. Если произошел конфликт, давайте убедимся, что мы бросаем исключение conflict, в противном случае мы можем бросить исключение unauthorized. Вы можете заметить, что мы используем уникальный код ошибки здесь, так как мы используем Postgres в качестве базы данных, поэтому эта конкретная логика конфликта здесь может выглядеть по-другому, если вы используете другую базу данных в своих будущих приложениях.

Отлично, двигаемся дальше, сохраняем наши изменения и создаем фактическую конечную точку для всего, открыв контроллер аутентификации Google. Давайте начнем с обновления префикса контроллера здесь, чтобы он соответствовал другим маршрутам - authentication/google.

Затем давайте внедрим службу аутентификации Google, используя стандартный подход. Теперь внутри нашего класса давайте объявим единственный маршрут authenticate, который вызывает соответствующий метод службы аутентификации Google.

У нас пока нет определенного класса DTO для Google Token, давайте перейдем в наш каталог DTO и создадим там новый файл google-token.dto. Внутри этого файла давайте добавим простой класс с одним свойством, представляющим собой токен Google.

После этого вернемся к нашему классу контроллера и убедимся, что мы добавляем импорт класса MissingDTO.

И, наконец, чтобы сделать этот маршрут общедоступным, давайте убедимся, что мы аннотируем весь контроллер декоратором Auth, передавая AuthType None.

Еще одна вещь, прежде чем продолжить, так как наш интерфейс размещен на порту 4000, а наш API - на порту 3000, нам нужно включить CORS или кросс-оригинную передачу ресурсов. Легкое исправление. Давайте откроем наш файл main.ts и добавим следующую строку: app.enable CORS, и это все.

С настройкой всего теперь давайте запустим наше React-приложение, если вы уже его настроили, чтобы мы могли протестировать весь поток. Если мы откроем наш браузер на порту 4000, когда наше React-приложение будет построено и работать, мы должны увидеть нашу кнопку входа через Google.

Давайте щелкнем "Sign In as your account", и должно открыться всплывающее окно или отдельная вкладка в полноэкранном режиме, позволяющая вам выбрать учетную запись, с которой вы хотите войти.

И после успешной авторизации вы должны увидеть, что доступ и обновление токенов выводятся в консоль Chrome. И вот оно. Всего за несколько шагов мы смогли интегрировать наше приложение Nest с аутентификацией Google, одним из самых популярных поставщиков одноразовой аутентификации в современном мире.


## Two-factor authentication

Двухфакторная аутентификация, или 2FA, - это процесс, при котором пользователю необходимо подтвердить свою личность двумя уникальными способами, прежде чем он получит доступ к системе. 2FA расширяет этот подход, добавляя дополнительный шаг в процесс аутентификации, обычно требуя от пользователя ввода одноразового токена, который генерируется динамически и доставляется методом, который может использовать только сам пользователь, будь то Google Authenticator, SMS или множество других вариантов. 2FA защищает от фишинга, социальной инженерии и атак методом перебора паролей и является важной частью большинства систем безопасной аутентификации.

Перед тем как начать, давайте установим несколько необходимых зависимостей, которые нам понадобятся для продолжения. OTPlib - это библиотека одноразовых паролей или OTP на JavaScript для генерации и проверки одноразовых паролей. Она совместима с приложением Google Authenticator, которое мы будем использовать в этом уроке. Пакет QR code - это генератор двухмерных QR-кодов. Мы продолжим далее, так как у нас уже установлены эти зависимости, но если вы следуете за уроком, просто приостановите видео и вернитесь, когда все будет готово.

С установкой завершено, давайте создадим службу аутентификации OTP с использованием NestJS CLI, где мы будем хранить большую часть нашей бизнес-логики OTP. Прежде чем начать реализацию службы, давайте откроем наш файл .env и объявим там новую переменную окружения с именем TFA_app_name. В этой переменной мы будем хранить имя приложения двухфакторной аутентификации, и мы просто назовем его auth-playground, но вы можете дать ему любое имя, которое вам нравится.

Теперь перейдем к нашей службе. Давайте начнем с внедрения двух зависимостей в наш конструктор. Мы будем использовать службу конфигурации для извлечения переменной окружения с именем TFA_app_name и репозиторий пользователей, чтобы включить двухфакторную аутентификацию после успешной генерации QR-кода.

Первым делом давайте объявим метод generateSecret. Каждому пользователю должен быть назначен уникальный секретный ключ, поэтому внутри этого метода давайте сгенерируем его с использованием библиотеки OTPlib. Убедимся, что мы импортируем объект Authenticator из пакета OTPlib и вызываем метод generateSecret.

Затем давайте сначала извлечем имя приложения с помощью метода configService.getOrThrow, а затем сгенерируем URI с использованием метода AuthenticatorKeyUri.

И, наконец, вернем как URI, так и секрет из этого метода.

Также нам понадобится метод, который проверяет предоставленный пользователем код или токен из приложения аутентификации, в нашем случае Google Authenticator. Давайте определим метод verifyCode, который также использует Authenticator из OTPlib и на этот раз вызывает метод verified.

Перед тем как двигаться дальше, давайте перейдем к сущности пользователя и добавим здесь два столбца, которые нам понадобятся для наших потребностей в двухфакторной аутентификации. Сначала нам нужен столбец, который определяет, включена ли двухфакторная аутентификация для данного пользователя, и давайте убедимся, что значение по умолчанию установлено в false. Для второго столбца давайте создадим столбец с именем tfasecret, который мы будем использовать для хранения секрета двухфакторной аутентификации пользователя.

С настройкой всего этого давайте вернемся к нашей службе аутентификации OTP и добавим последний метод, который нам здесь нужен, и который включает двухфакторную аутентификацию для данного пользователя. Обратите внимание, что мы оставили комментарий о том, что в идеале мы хотели бы зашифровать секрет вместо хранения его в открытом виде. Но также обратите внимание, что мы не смогли бы использовать хеширование здесь, так как для проверки предоставленного пользователем кода требуется исходный секрет.

Отлично! С этой службой готовой к использованию, давайте перейдем к контроллеру аутентификации и добавим там новую конечную точку, чтобы мы могли получить доступ ко всему этому. Эта конечная точка вернет QR-код, специфичный для пользователя, чтобы его могли отсканировать приложения аутентификации пользователя.

Для этого нам понадобится доступ к собственному объекту ответа Express.js через декоратор res. Также обратите внимание, что этот метод аннотирован декоратором Auth, включая аутентификацию только для этой конечной точки, так как другие маршруты, зарегистрированные в этом контроллере, по умолчанию являются общедоступными.

Внутри этого метода сначала давайте сгенерируем секрет для активного пользователя с использованием только что созданного нами метода generateSecret. Затем давайте включим 2FA, используя активный адрес электронной почты пользователя и только что сгенерированный нами секрет, убедившись, что мы дожидаемся результатов. И, наконец, давайте установим тип ответа на PNG, так как мы будем возвращать изображение QR-кода, и вернем сгенерированный QR-код пользователю. Обратите внимание, что мы импортировали функцию toFileStreamHelper из библиотеки QR-кодов, которая записывает изображение QR-кода в поток.

Давайте сохраните наши изменения, перейдем в Insomnia и войдем снова, чтобы убедиться, что мы не используем просроченный токен. Теперь давайте попробуем обратиться к только что созданной конечной точке аутентификации/2FA/generate, чтобы убедиться, что все работает. И отлично! Мы видим, что получили изображение QR-кода в ответе. Теперь мы можем отсканировать QR-код с помощью приложения Google Authenticator на мобильном устройстве.

Отлично, сгенерировав QR-код, нам нужно теперь обновить процесс входа, чтобы потребовать от пользователя передачу TOTP, или одноразового пароля на основе времени, в данном случае нашего кода Google Authenticator, наряду с адресом электронной почты и паролем.

Давайте перейдем к классу DTO для входа и добавим там новое поле с именем TFA code типа string. Мы укажем его как необязательное, так как оно требуется только для пользователей, у которых включена 2FA.

Теперь давайте откроем нашу службу аутентификации и внедрим в нее службу аутентификации OTP, так как нам понадобится ее для проверки токенов. Прокрутим вниз к методу входа и, прежде чем генерировать токены доступа и обновления, давайте добавим новое условие, проверяющее, включена ли 2FA у данного пользователя. И если да, давайте проверим код и выбросим исключение, если он недействителен. Отлично! Давайте убедимся, что мы сохраняем наши изменения, перейдем в Insomnia и попробуем войти еще раз. Так как у нашего пользователя включена 2FA, так как мы сгенерировали QR-код, обратившись к конечной точке 2FA/generate, мы получили ошибку "недопустимый код 2FA", как и следовало ожидать.

Итак, давайте обновим тело запроса и передадим соответствующий код TFA, который вы можете получить из приложения Google Authenticator на вашем мобильном устройстве. Обратите внимание, что это, конечно же, будет отличаться от того, что мы вводим здесь в данный момент записи. Если мы нажмем "Send", вы увидите, что мы успешно вошли. Итак, в этом уроке мы сделали все, что нам нужно, чтобы настроить 2FA в наших будущих приложениях и повысить безопасность входа на новый уровень.


## Sessions with Passport

Passport - это самая популярная библиотека аутентификации для Node.js. Она хорошо известна в сообществе и успешно используется во многих производственных приложениях. Passport имеет богатую экосистему стратегий, которые реализуют различные механизмы аутентификации. Несмотря на свою простоту, выбор набора стратегий Passport весьма обширен и предоставляет множество вариаций. Passport абстрагирует эти разнообразные шаги в стандартный шаблон, а модуль NestJS Passport оборачивает и стандартизирует этот шаблон в знакомые конструкции Nest.

До сих пор, в течение всего этого дополнительного курса, мы реализовали всё сами, не используя Passport. Это сделано, чтобы показать, что даже несмотря на то, что Passport отлично подходит и очень популярен, вы можете построить полноценную гибкую систему аутентификации и без его использования.

В этом уроке мы покажем вам, как можно интегрировать Passport с Nest, что может быть полезно в ситуациях, когда вам не нужен абсолютный контроль, как во всех кастомных решениях, которые мы использовали на протяжении этого курса. Также, чтобы добавить немного разнообразия, вместо использования JWT для аутентификации, мы будем использовать серверные сессии, что является ещё одним отличным вариантом для аутентификации и может иметь смысл в некоторых приложениях и обстоятельствах.

Сессия позволяет веб-приложениям сохранять данные о текущем пользователе между запросами. Механизм, который мы используем для этого, - это куки, которые позволяют серверу создавать небольшие блоки контекстных данных, размещенных в браузере или устройстве пользователя.

Итак, в большой картины это означает, что при входе пользователя мы генерируем идентификатор сессии и отправляем его пользователю, ожидая, что он будет отправлен нам в последующих запросах в виде куки. На стороне API мы можем сравнить полученный идентификатор (т.е. идентификатор сессии) с идентификатором, который у нас хранится в памяти.

Основная проблема такого подхода заключается в том, что он полностью зависит от состояния. Если перед API находится балансировщик нагрузки, пользователь может аутентифицироваться через один экземпляр (или узел) и затем получать доступ к ресурсам через другой экземпляр. В этом случае сервер не сможет распознать пользователя.

Для решения этой проблемы обычно используется база данных для хранения идентификаторов сессий, чаще всего Redis.

Прежде чем начать, давайте откроем терминалы и установим несколько зависимостей: Passport, @nestjs/passport и Express Session. Также установим соответствующие определения типов, но убедимся, что они сохранены как зависимости разработки.

После завершения установки давайте откроем файл .env и добавим новую переменную окружения для секрета сессии. Нам нужен секрет для шифрования и дешифрования идентификаторов сессий.

Далее откроем файл модуля IAM и добавим два импорта для Express Session и Passport. Затем сделаем так, чтобы наш класс модуля IAM реализовывал интерфейс NestModule. Этот интерфейс требует, чтобы мы предоставили метод configure, который принимает один аргумент - middleware consumer, позволяющий нам регистрировать функции промежуточного программного обеспечения. Здесь давайте зарегистрируем несколько функций промежуточного программного обеспечения, связанных с Passport.

С нашими функциями промежуточного программного обеспечения зарегистрированными, давайте создадим новую службу аутентификации сессии с использованием NestJS CLI. Мы могли бы вместо этого модифицировать существующую службу аутентификации, которая в настоящее время реализует аутентификацию на основе JWT, но так как мы не хотим вас путать и смешивать эти два концепта, мы решили оставить их отдельно.

Затем мы генерируем отдельный контроллер для аутентификации сессии.

С этими файлами давайте перейдем к службе аутентификации сессии и начнем с внедрения двух провайдеров в конструктор: user repository и нашей службы хеширования.

В этой службе мы реализуем только один метод - sign-in, который будет выглядеть почти так же, как метод sign-in в нашей службе аутентификации, который мы создали некоторое время назад. Мы уберем код аутентификации двухфакторной аутентификации, чтобы сделать процесс аутентификации более понятным, и вместо генерации токенов при успешном входе мы просто вернем сущность пользователя.

Затем мы перейдем к классу контроллера аутентификации сессии. Сначала декорируем его декоратором Auth, передавая в него AuthType.None, чтобы убедиться, что все маршруты, объявленные в этом контроллере, являются общедоступными. Затем внедрим службу аутентификации сессии с использованием стандартного подхода. Наконец, добавим метод sign-in, который будет похож на метод sign-in из нашего предыдущего контроллера аутентификации. Одно отличие заключается в том, что мы будем использовать метод requestLogin, предоставляемый Passport, передавая в него сущность пользователя, которую нужно войти в систему.

Вы могли заметить, что мы также используем Promisify, так как исходный метод login реализует стиль обратного вызова, и Promisify помогает преобразовать API обратного вызова в обещание.

Метод requestLogin из Passport требует от нас предоставить логику сериализации и десериализации пользователя. Давайте установим эту логику, откроем терминалы и создадим новый класс с помощью NestJS CLI с именем UserSerializer и поместим его в новую папку Serializers, где мы будем размещать всю связанную логику. Перейдем к этому недавно созданному классу и сделаем его расширяющим класс PassportSerializer из пакета @nestjs/passport. Внутри этого класса давайте объявим два метода. Метод serializeUser принимает объект сущности пользователя, который мы передаем в метод requestLogin, и отображает его на активные данные пользователя, которые мы видели в предыдущих уроках. Метод deserializeUser просто передает десериализованный пейлоад вверх. Обратите внимание, что мы могли бы, возможно, использовать здесь репозиторий пользователей для извлечения сущности пользователя на основе активных данных пользователя, но поскольку этот метод выполняется при каждом запросе, это, безусловно, повлияло бы на производительность, поэтому будьте внимательны к тому, чтобы делать что-то подобное в будущем.

Теперь давайте сохраните наши изменения, откроем терминалы и создадим еще один класс - SessionGuard. После создания перейдем к этому классу и добавим следующие строки в метод CanActivate, где нам нужно только получить текущий запрос и вернуть результат метода request.isAuthenticated из Passport, который возвращает булево значение, сообщая нам, аутентифицирован ли текущий пользователь или нет.

Прекрасно, с нашей системой аутентификации на основе сессий всё готово к работе. Чтобы протестировать всё, перейдем к контроллеру аутентификации сессии и добавим туда случайный маршрут для демонстрации и защитим его с помощью нашей новой SessionGuard.

Теперь давайте убедимся, что мы сохраняем наши изменения, и прежде чем проверять наши конечные точки, давайте убедимся, что мы регистрируем UserSerializer как провайдер. Перейдем к нашему модулю IAM, добавим класс UserSerializer в массив провайдеров и сохраните наши изменения.

Отлично, теперь перейдем к Insomnia и начнем с вызова конечной точки Session-Authentication-SignInPost, убедившись, что мы передаем учетные данные в теле запроса, так же, как мы делаем это с аутентификацией на основе JWT. Как мы видим, мы получили ответ 200 OK, так что всё работает, и мы смогли войти и создать сессию. Замечательно, теперь, если мы перейдем на вкладку Cookies, мы увидим наш SessionID. Теперь давайте перейдем к нашему защищенному random маршруту, который должен отобразить "hello" и адрес электронной почты пользователя, если всё работает правильно и мы аутентифицированы. И вуаля, как мы видим, мы получили ответ 200 OK, и мы можем видеть "hello, user1@nestjs.com", что является нашей текущей электронной почтой, с которой мы вошли в систему. Фантастика.

Как мы упоминали в начале этого урока, идентификаторы сессий хранятся в памяти. Поэтому в реальных системах обычно используется внешняя база данных для отслеживания сессий. Еще одна важная проблема, которую следует помнить, заключается в том, что каждый раз, когда вы перезагружаете свое API, например, останавливаете или запускаете его, выполняете новые изменения и так далее, все сеансы будут утеряны, и все пользователи выйдут из системы. Для демонстрации мы используем Redis, так как его довольно просто настроить, плюс у нас уже есть его конфигурация в нашем приложении, так как мы использовали Redis для обновления токенов в предыдущих уроках. Но вы можете использовать любую базу данных на ваш выбор для хранения данных о сессиях. Redis отлично подходит, так как он очень легкий и чрезвычайно быстрый, поэтому это безусловно отличный вариант для этой цели.

Таким образом, в несколько шагов мы улучшили нашу систему аутентификации на основе сессий с использованием Redis. Всё должно работать так же, как и раньше, но теперь, если мы останавливаем и перезапускаем наше приложение, мы увидим, что мы по-прежнему остаемся в системе и можем получить доступ к защищенному маршруту, который мы создали. Для развлечения посмотрите в свою базу данных Redis, и вы даже сможете увидеть ключи для ваших сессий.

Мы прошли через многое в этом уроке, показав, насколько легко использовать Passport. Passport, конечно, отнимает часть нашего контроля, так как у нас нет абсолютного ручного контроля над каждой маленькой деталью в процессе аутентификации в наших приложениях, но, с другой стороны, он значительно упрощает нам задачу. Обратите внимание, что использование Passport с JWT очень похоже на то, что мы делали здесь. Мы не будем демонстрировать это в этом курсе, но если вас интересует именно это, мы подробно рассказываем об этом в официальной документации NestJS. Вы можете найти ссылку на это ниже видео урока. Спасибо еще раз за просмотр.