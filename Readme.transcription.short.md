Краткое содержание

## Implementing Refresh Tokens

Это текст описывает введение обновляющих токенов в систему аутентификации и авторизации. Обновляющий токен - это специальный токен, который позволяет автоматически обновлять доступные токены с коротким сроком действия, без необходимости повторной аутентификации каждый раз. Обновляющие токены должны возвращаться при первоначальной аутентификации и храниться надежно. Затем текст переходит к практической реализации этой функциональности, включая настройку времени жизни обновляющих токенов и изменение логики генерации токенов. Завершается текст рассмотрением тестирования новой функциональности в программе Insomnia.

Итак, в кратком изложении: текст описывает введение и реализацию обновляющих токенов в системе аутентификации и авторизации для автоматического обновления доступных токенов с целью обеспечения безопасности приложения.


## Invalidating Tokens?

Этот текст рассматривает преимущество JSON Web Tokens (JWT), а именно их "stateless" (без состояния) характеристику, которая позволяет авторизовывать запросы без постоянной проверки в центральной базе данных. Однако, он также поднимает вопросы о безопасности, такие как отмена токенов и их управление.

Автор предлагает решение в виде "поворота токена обновления", при котором старые обновляющие токены аннулируются после использования для создания новых пар токенов. Это требует использования базы данных, такой как Redis, для хранения информации о токенах. Автор также указывает, что это решение делает JWT "stateful" (со состоянием), но является промежуточным решением между полностью "stateless" и "stateful" методами.

Затем автор переходит к шагам по настройке Redis и реализации хранилища для токенов обновления, а также к использованию интерфейсов жизненного цикла Nest.js. Он также отмечает, что это решение является упрощенным для целей учебного курса и что в реальных проектах следует рассмотреть более сложные решения.

Таким образом, текст обсуждает проблему управления безопасностью и аннулирования токенов в JWT и предлагает промежуточное решение с использованием Redis для хранения информации о токенах обновления.


## Role-Based Access Control

Этот текст объясняет концепцию авторизации и её различие от аутентификации. Авторизация означает предоставление пользователям разрешений на доступ к определенным ресурсам или функциям. Она независима от процесса аутентификации, который обсуждался ранее. Авторизация может быть управляема на основе ролей и привилегий, используя механизм управления доступом на основе ролей (RBAC).

RBAC позволяет группировать пользователей в роли на основе их обязанностей. Например, администратор может иметь доступ к управлению ресурсами, в то время как обычные пользователи только могут просматривать эти ресурсы. Это позволяет упростить управление доступом, так как разрешения назначаются ролям, а не каждому пользователю индивидуально.

Текст также описывает создание перечисления ролей для проекта и добавление столбца "роль" в сущность пользователя. Предполагается, что роли могут быть, например, "обычный пользователь" и "администратор". Важно отметить, что в реальных проектах роли могут быть более сложными и динамическими, и их управление может потребовать базы данных и административной панели.

Текст также упоминает использование функции REPL (Read-Eval-Print Loop) для обновления ролей для существующих пользователей в базе данных. Это предназначено для удобства обучения и тестирования, и не является рекомендуемым способом управления данными в производственной среде.


## Claims-based Authorization

В данном тексте объясняется концепция авторизации на основе заявок (claims-based authorization) и различия между авторизацией и аутентификацией. Авторизация на основе заявок позволяет определять несколько разрешений и назначать их пользователям, вместо того чтобы определять набор ролей для пользователей. Это предоставляет более гибкий и детализированный контроль над доступом к ресурсам.

Авторизация на основе заявок полезна, когда требуется точный контроль над разрешениями пользователей. Например, разные пользователи могут иметь разные права на создание, обновление и удаление ресурсов. В тексте также указывается, что обычно разрешения хранятся в базе данных, и реальное приложение может использовать таблицу разрешений.

Для реализации авторизации на основе заявок, автор предлагает создать перечисление разрешений и добавить декораторы разрешений к методам, которые требуют определенных разрешений. Затем создается стража разрешений, которая проверяет, имеет ли пользователь все необходимые разрешения для доступа к определенной конечной точке.

Текст также уточняет, что на практике разрешения могут быть связаны с ролями или храниться в базе данных. Далее показывается, как добавить столбец "разрешения" к сущности пользователей и как включить это поле в токен доступа.

В конечном итоге текст демонстрирует, как назначать разрешения конкретному пользователю с использованием REPL (Read-Eval-Print Loop), и как проверять эти разрешения при доступе к определенным ресурсам.


## Policy-based Authorization

Политика определяет требование или совокупность требований, которые пользователь должен удовлетворить, чтобы получить доступ к ресурсу.
Фактически, даже если вы используете авторизацию на основе заявок или ролей, на самом деле вы используете авторизацию на основе политики, но как жестко закодированные политики.
Подумайте о декораторе ролей, который мы создали, который требовал, чтобы у пользователя была определенная роль, по сути создавая жестко закодированную политику, реализованную внутри нашей стражи ролей.
Просто как отмазка, что в этом уроке мы рассмотрим некоторые более сложные сценарии авторизации, которые обычно не требуются для большинства приложений.
Обычно достаточно авторизации на основе ролей или на основе заявок, но мы подумали, что может быть полезно продемонстрировать авторизацию на основе политики, на всякий случай, если вам это понадобится в будущих приложениях.
Хорошо, перейдем к нашей среде разработки и посмотрим, как мы могли бы использовать политики в нашем приложении, если бы мы почувствовали, что они нам нужны.
Внутри каталога авторизации создадим следующее дерево каталогов: policies/interfaces.
В папке interfaces создадим новый файл и назовем его policy.interface.ts.
Внутри этого файла объявим интерфейс политики.
Это будет очень простой интерфейс, состоящий из одного свойства, name, которое мы будем использовать, чтобы упростить отладку.
Далее создадим еще один файл рядом с интерфейсом политики и назовем его policy-handler.ts.
Внутри этого файла объявим интерфейс обработчика политики.
Этот интерфейс требует, чтобы метод handle был реализован.
Этот метод handle будет принимать два аргумента: policy, который представляет собой соответствующий экземпляр политики, для которой этот обработчик был реализован.
Обратите внимание на обобщенный тип T, так как у разных обработчиков политики могут быть собственные политики.
И второй аргумент - объект активных пользовательских данных, указывающий, кто является контекстным пользователем, для которого мы выполняем эту политику.
Отлично.
С этими интерфейсами на месте, перейдем к классу хранения обработчиков политики.
Этот класс будет служить нам как статическая коллекция map, связывающая политики с соответствующими обработчиками политики.
Каждая политика должна иметь ровно один обработчик политики.
Обработчик политики будет отвечать за обработку конкретной политики.
Не волнуйтесь, все это станет более понятным через момент.
Давайте начнем с создания файла policy-handlers.storage в нашем каталоге политик и внутри этого файла объявим простой класс, который содержит одну закрытую коллекцию.
Также убедимся, что он аннотирован декоратором injectable.
Первый аргумент типа, который мы указываем для класса map, указывает тип наших ключей в этой коллекции.
Поскольку ключи представляют собой классы, представляющие наши политики, мы должны использовать тип policy здесь.
Второй аргумент типа, который мы видим здесь, представляет значения для этих ключей.
Здесь мы использовали обработчик политики типа any, так как мы будем использовать экземпляры обработчика политики в качестве значений.
Обратите внимание, что в случае ключей мы работаем с типами, а не с конкретными экземплярами, так как мы хотим позволить разработчикам вручную создавать и настраивать политики, например, если разные конечные точки в нашем приложении имеют разные требования.
Хорошо, достаточно теории, далее нам понадобятся два метода, которые позволяют нам работать с внутренней коллекцией этого класса хранения: get, для получения класса обработчика политики на основе данного класса политики, и метод add, для связывания политик с обработчиками политики.
Обратите внимание, что мы использовали суффикс cls здесь, чтобы указать, что мы работаем с классами, а не с экземплярами.
С этим классом хранения на месте мы можем начать создавать нашу первую политику.
Для демонстрационных целей мы реализуем очень настраиваемую политику - политику участника фреймворка, которая проверяет, зарегистрирован ли адрес электронной почты пользователя в домене nestjs.com.
Итак, внутри нашего каталога политик создадим новый файл и назовем его framework-contributor.policy.ts.
Внутри этого файла создадим простой класс с именем framework contributor policy и заставим его реализовать интерфейс политики.
Также не забудем указать имя этой политики.
Обратите внимание, что обычно мы рекомендуем создать еще один файл рядом с этим и назвать его framework-contributor-policy-handler.ts, но поскольку политика участника фреймворка очень проста, коротка и проста, чтобы облегчить понимание, мы решили создать обработчик прямо внутри этого файла сразу после определения политики.
Итак, давайте перейдем к созданию обработчика политики участника фреймворка сейчас.
Еще раз убедимся, что он аннотирован декоратором injectable и что он реализует наш интерфейс обработчика политики.
Затем объявим конструктор и внедрим провайдер хранилища обработчиков политики.
Внутри этого конструктора, используя метод add хранилища обработчиков политики, который мы создали немного ранее, свяжем этот обработчик соответствующей политикой участника фреймворка следующим образом.
Поскольку все наши обработчики политики предназначены для работы асинхронно, давайте пометим этот метод как async.
И отсюда мы можем начать реализовывать нашу фактическую политику.
Внутри метода handle добавим следующую логику, которую вы можете найти ниже видеоряда курса.
В коде, показанном здесь, мы просто проверяем, заканчивается ли адрес электронной почты пользователя на nestjs.com, и если нет, то выбрасываем исключение.
И все. Помните, что мы создаем очень простую политику только для демонстрационных целей, но, надеюсь, вы видите возможности здесь и понимаете, почему такой тип авторизации может быть полезен в определенных приложениях и обстоятельствах.
Прежде чем мы продолжим, давайте откроем файл immodule и убедимся, что мы зарегистрировали как провайдеры как хранилище обработчиков политики, так и класс обработчика политики участника фреймворка.
Вот почему мы добавили эти декораторы injectable.
Отлично.
Теперь есть еще два шага, которые нам нужно сделать и которые мы уже рассмотрели в предыдущих уроках.
Во-первых, внутри нашего каталога декораторов создадим новый декоратор policies для прикрепления политик к конечным точкам или контроллерам.
Как обычно, весь код для этого можно найти ниже видеоряда курса.
Как только мы закончим, создадим новую стражу policies, которая выполняет политики, специфичные для контекста, для данной операции.
Мы начнем с вставки нашей обычной заготовки, чтения метаданных, игнорирования стражи, если политики отсутствуют и так далее.
Мы уже делали это несколько раз в этом курсе.
И с этим кодом на месте, давайте начнем реализовывать логику, специфичную для политики сейчас.
Теперь давайте внедрим хранилище обработчиков политики, которое мы создали, так как нам понадобится оно для получения самих обработчиков политики.
Если политики определены, то давайте переберем их, сопоставив их с соответствующими экземплярами обработчиков политики и вызовем метод обработчика, передавая экземпляр политики в качестве первого параметра и активные пользовательские данные в качестве второго параметра.
Обратите внимание, что для получения соответствующего обработчика нам нужно передать ссылку на конструктор политики.
Как вы помните, наше хранилище обработчиков политики связывает обработчики с классами политики, а не с экземплярами.
Поскольку методы handle наших обработчиков политики асинхронны, давайте используем здесь promise.all, чтобы дождаться результатов.
И в случае возникновения ошибки, давайте используем catch и отобразим ошибки как ошибку запрета.
Отлично!
Со всем этим на месте, давайте перейдем к файлу модуля im и заменим стражу разрешений на нашу новую стражу политики.
Затем откроем файл контроллера кофе, и вместо использования декоратора разрешений давайте закомментируем его и используем аннотацию политик, применяя политику участника фреймворка.
Здорово!
Обратите внимание, что вы можете применить несколько политик к одной конечной точке, как показано ниже, если это необходимо.
Хорошо, давайте сохраните наши изменения, перейдем к программе Insomnia и протестируем все, чтобы увидеть эти политики в действии.
Давайте нажмем "Отправить" и проверим, можем ли мы получить доступ к конечной точке POST /coffees.
Обратите внимание, что если вы получаете ошибку 401, убедитесь, что вы снова вошли в систему и обновили свой токен доступа.
И да, мы видим, что у нас есть доступ, поскольку адрес электронной почты нашего пользователя - user1 at nestjs.com.
Теперь вернемся к нашей среде разработки, откроем класс обработчика политики участника фреймворка, чтобы вместо проверки наличия nestjs.com ожидать trilon.io.
Сохраните наши изменения, перейдите к Insomnia и попробуйте еще раз нажать на ту же конечную точку.
И, как видите, у нас теперь нет разрешения на доступ к этой конечной точке из-за ограничений авторизации политики, которые мы установили для нее.
Мы рассмотрели многое в этом уроке, и, надеюсь, вы видите ценность авторизации на основе политики, а также то, как она действительно может быть необходима не в каждом приложении и особенно не в каждой конечной точке.
Как и в большинстве инструментов, есть случаи использования для всего.
И с тем, что мы рассмотрели в этом уроке, вы сможете покрыть даже самые сложные сценарии авторизации в ваших будущих приложениях Nest.


## Introduction to API Keys

API-ключ – это уникальный идентификатор, используемый для взаимодействия с API или выполнения запросов к нему. Он может быть использован либо для анонимного доступа к публичным данным приложения, либо для создания вторичных учетных данных, которые позволяют отправлять запросы от имени конкретного пользователя.

В первом случае API-ключи удобны для доступа к общедоступным данным и для идентификации запросов, связанных с вашим проектом. Во втором случае API-ключи представляют собой вторичные учетные записи пользователей, которые имеют определенные права доступа, в зависимости от настроенных параметров.

Выбор между этими двумя вариантами зависит от типа вашего приложения. Например, для продукта SaaS, где пользователи создают собственные проекты, первый вариант, в котором API-ключи связаны с проектами, может быть более подходящим. В случае социальной сети или аналогичного приложения, второй вариант, позволяющий пользователям создавать собственные API-ключи для взаимодействия с вашим API, может быть более полезным.

Пользователи могут создавать API-ключи, которые позволяют им взаимодействовать с вашим API от имени сторонних инструментов. Эти ключи могут иметь определенные права и области доступа, управляемые пользователями.

Выбор между этими подходами зависит от потребностей вашего проекта. В следующих уроках будет рассмотрена реализация второго варианта, но первый подход также будет рассмотрен и может быть практически аналогичен в реализации.


## Integrate API Keys feature

1.
В этой главе мы реализуем функцию API-ключей для отправки запросов от имени пользователя. Начнем с создания класса сущности под названием API-key и поместим его в каталог users/API-keys/entities. Мы уберем суффикс "entity", добавим несколько столбцов (ID, key, UUID), и установим отношение многие-к-одному с сущностью пользователя.

Далее мы зарегистрируем сущность API-key в нашем приложении, обновив также сущность пользователя, чтобы указать, что пользователь - владелец отношения один-ко-многим с API-ключами.

Затем создадим новую службу API-keys в каталоге authentification и определим в ней четыре метода: createAndHash для создания и хеширования API-ключей, validate для проверки API-ключей, extractIdFromAPIKey для извлечения ID из API-ключа и generateAPIKey для генерации строк API-ключей.

Мы также объявим интерфейс payload для API-ключей, содержащий API-key (дружественный пользовательский API-ключ) и hashed-key (хешированная версия API-ключа), и внедрим службу хеширования в конструктор службы API-keys.

Метод generateAPIKey генерирует случайную уникальную строку API-ключа, добавляет префикс API-key и возвращает ее в формате base64. Метод createAndHash генерирует API-ключ и его хеш, а метод validate проверяет API-ключи. Метод extractIdFromAPIKey извлекает ID из закодированного API-ключа.

Затем создаем охранник API-ключа с использованием схемы Nest.js. В нем извлекаем объект запроса из контекста выполнения, определяем метод extractKeyFromHeader для извлечения API-ключа из заголовка авторизации. Мы также обновляем охранник токена доступа для поддержки этой проверки.

В методе canActivate охранника API-ключа мы извлекаем API-ключ и, если он не определен, вызываем исключение "unauthorized". Мы также внедряем службу API-key и репозиторий API-keys для проверки входящих API-ключей и получения записей API-ключей из базы данных. Используя метод extractIdFromAPIKey, извлекаем идентификатор API-ключа из закодированной строки.

2. 
В данном уроке мы добавляем обработку исключений с использованием блоков try-catch. В блоке try мы извлекаем сущность API-key из таблицы API-keys, используя извлеченный из закодированной строки ID. Мы также убеждаемся, что ORM автоматически заполняет связанную сущность пользователя в этом запросе.

Затем мы используем метод validate службы API-keys для проверки API-ключа и его хеша, который хранится в базе данных. Для разрешения использования API-ключей от имени конкретных пользователей мы также присваиваем связанную сущность пользователя объекту запроса.

Далее мы внедряем охранник API-ключа в охранник аутентификации и обновляем перечисление auth type enum, добавляя туда API-ключ.

Завершая настройку, мы регистрируем репозиторий API-key в контексте модуля IAM, чтобы он мог быть внедрен в охранник аутентификации.

Чтобы протестировать это, мы создаем тестовый API-ключ в REPL Nest.js. Затем мы обновляем заголовок авторизации в Insomnia, используя сгенерированный API-ключ, и отправляем запрос к точке доступа Coffee's. В результате мы успешно аутентифицируемся от имени пользователя и видим, что запрос выполнен успешно.

Теперь наша точка доступа Coffee's поддерживает как биржевые токены, так и аутентификацию на основе API-ключей, расширяя возможности нашего приложения.

## Google Authentication - NestJS portion

В этом уроке мы реализовали аутентификацию через Google в нашем приложении Nest. Мы начали с настройки переменных окружения для Google Client ID и Google Client Secret, полученных из Google Cloud Platform.

Затем мы установили библиотеку Google Auth и создали службу и контроллер для аутентификации через Google.

В службе мы инициализировали OAuthClient с использованием полученных Client ID и Client Secret, внедрили необходимые зависимости и реализовали метод authenticate, который обрабатывает полученный токен Google и выполняет аутентификацию пользователя.

Мы также обновили сущность пользователя, добавив столбец для Google ID и сделав пароль nullable, так как пользователи, использующие Google для входа, не имеют обычных паролей.

В контроллере мы создали маршрут authenticate, который вызывает метод аутентификации Google и аннотировали контроллер декоратором Auth с параметром AuthType.None, чтобы сделать маршрут общедоступным.

Мы также создали DTO google-token.dto и добавили CORS-настройки в файл main.ts.

Наконец, мы запустили React-приложение для тестирования аутентификации через Google и убедились, что процесс работает успешно.

Таким образом, мы интегрировали аутентификацию Google в наше приложение Nest, предоставляя пользователям удобную опцию для регистрации и входа в систему.


## Two-factor authentication

1.
Двухфакторная аутентификация (2FA) - это метод обеспечения безопасности, требующий от пользователей двойной проверки их личности перед получением доступа к системе. Этот процесс включает в себя ввод одноразового токена, который генерируется динамически и отправляется только пользователю, например, с помощью Google Authenticator или SMS. 2FA защищает от различных видов атак, таких как фишинг и перебор паролей, и является важной частью систем безопасной аутентификации.

В этом уроке мы рассмотрели настройку двухфакторной аутентификации в приложении NestJS. Мы установили необходимые зависимости, такие как OTPlib для генерации и проверки одноразовых паролей и QR-кодов для приложения Google Authenticator. Затем мы создали службу аутентификации OTP, в которой сгенерировали секретный ключ для каждого пользователя и создали URI для настройки Google Authenticator. Мы также добавили метод для проверки предоставленного пользователем кода.

Для поддержки двухфакторной аутентификации мы обновили сущность пользователя, добавив столбцы для включения 2FA и хранения секретного ключа.

Затем мы добавили конечную точку в контроллере аутентификации, которая возвращает QR-код для настройки Google Authenticator. Мы защитили этот маршрут 2FA, чтобы обеспечить безопасность доступа к нему.

Этот урок помог настроить двухфакторную аутентификацию в нашем приложении, предоставляя пользователям более высокий уровень безопасности и защиту от потенциальных атак.

2.
В этом уроке мы настроили двухфакторную аутентификацию (2FA) в нашем приложении. Начиная с создания QR-кода, предназначенного для приложения Google Authenticator, мы сгенерировали уникальный секрет для активного пользователя, включили 2FA, и в ответ на запрос отдали QR-код в виде изображения. Для этого мы использовали библиотеку OTPlib и QR-коды.

Затем мы обновили процесс входа в систему, требуя от пользователя также ввод TOTP (одноразового пароля на основе времени), полученного из приложения Google Authenticator. Мы модифицировали класс DTO для входа, добавив поле TFA code для передачи этого кода.

В службе аутентификации мы интегрировали службу аутентификации OTP, чтобы проверить TOTP код, если 2FA включена для данного пользователя. Теперь пользователи должны предоставить дополнительный код 2FA при входе, что повышает безопасность и защищает от несанкционированного доступа.

Этот урок помог настроить 2FA в нашем приложении и улучшил уровень безопасности при входе в систему.



## Sessions with Passport

1.
В этом уроке мы рассмотрели интеграцию библиотеки Passport с Nest.js для аутентификации в приложении. Passport - популярная библиотека аутентификации для Node.js с множеством стратегий. Мы узнали, что Nest.js Passport облегчает использование Passport в проектах Nest.js.

Вместо JWT-токенов для аутентификации, мы решили использовать серверные сессии, основанные на куки. Сессии позволяют хранить данные о текущем пользователе между запросами. Однако они могут столкнуться с проблемами при балансировке нагрузки и могут потребовать использования базы данных, такой как Redis, для хранения идентификаторов сессий.

Мы установили необходимые зависимости, включая Passport, @nestjs/passport и Express Session, а также добавили переменную окружения для секрета сессии.

Затем мы зарегистрировали функции промежуточного программного обеспечения Passport в модуле IAM и создали службу аутентификации сессии с соответствующим контроллером.

В службе аутентификации сессии мы реализовали метод sign-in, который позволяет пользователям аутентифицироваться и возвращает сущность пользователя вместо JWT-токенов.

Таким образом, этот урок демонстрирует, как интегрировать Passport для упрощения аутентификации в приложениях Nest.js и как использовать серверные сессии вместо JWT-токенов для аутентификации.

2.
В этом уроке мы рассмотрели интеграцию библиотеки Passport с Nest.js для аутентификации на основе сессий. Мы начали с создания контроллера аутентификации сессии и декорировали его, чтобы все его маршруты были общедоступными. Затем мы внедрили службу аутентификации сессии и добавили метод sign-in, который использует Passport для аутентификации пользователя.

Для правильной работы Passport требуется настройка сериализации и десериализации пользовательских данных. Мы создали класс UserSerializer, который расширяет PassportSerializer и определил методы serializeUser и deserializeUser для этой цели.

Далее мы создали SessionGuard, который проверяет, аутентифицирован ли текущий пользователь.

Мы также обсудили важные аспекты использования идентификаторов сессий, включая их хранение в памяти и рекомендацию использовать внешнюю базу данных, такую как Redis, для надежного сохранения сессий между перезапусками приложения.

В заключение, мы подчеркнули удобство использования библиотеки Passport для аутентификации в Nest.js и отметили, что с использованием JWT подходит для подобных целей и легко интегрируется с Nest.js.