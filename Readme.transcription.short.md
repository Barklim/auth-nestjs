Краткое содержание

## Implementing Refresh Tokens

Это текст описывает введение обновляющих токенов в систему аутентификации и авторизации. Обновляющий токен - это специальный токен, который позволяет автоматически обновлять доступные токены с коротким сроком действия, без необходимости повторной аутентификации каждый раз. Обновляющие токены должны возвращаться при первоначальной аутентификации и храниться надежно. Затем текст переходит к практической реализации этой функциональности, включая настройку времени жизни обновляющих токенов и изменение логики генерации токенов. Завершается текст рассмотрением тестирования новой функциональности в программе Insomnia.

Итак, в кратком изложении: текст описывает введение и реализацию обновляющих токенов в системе аутентификации и авторизации для автоматического обновления доступных токенов с целью обеспечения безопасности приложения.


## Invalidating Tokens?

Этот текст рассматривает преимущество JSON Web Tokens (JWT), а именно их "stateless" (без состояния) характеристику, которая позволяет авторизовывать запросы без постоянной проверки в центральной базе данных. Однако, он также поднимает вопросы о безопасности, такие как отмена токенов и их управление.

Автор предлагает решение в виде "поворота токена обновления", при котором старые обновляющие токены аннулируются после использования для создания новых пар токенов. Это требует использования базы данных, такой как Redis, для хранения информации о токенах. Автор также указывает, что это решение делает JWT "stateful" (со состоянием), но является промежуточным решением между полностью "stateless" и "stateful" методами.

Затем автор переходит к шагам по настройке Redis и реализации хранилища для токенов обновления, а также к использованию интерфейсов жизненного цикла Nest.js. Он также отмечает, что это решение является упрощенным для целей учебного курса и что в реальных проектах следует рассмотреть более сложные решения.

Таким образом, текст обсуждает проблему управления безопасностью и аннулирования токенов в JWT и предлагает промежуточное решение с использованием Redis для хранения информации о токенах обновления.


## Role-Based Access Control

Этот текст объясняет концепцию авторизации и её различие от аутентификации. Авторизация означает предоставление пользователям разрешений на доступ к определенным ресурсам или функциям. Она независима от процесса аутентификации, который обсуждался ранее. Авторизация может быть управляема на основе ролей и привилегий, используя механизм управления доступом на основе ролей (RBAC).

RBAC позволяет группировать пользователей в роли на основе их обязанностей. Например, администратор может иметь доступ к управлению ресурсами, в то время как обычные пользователи только могут просматривать эти ресурсы. Это позволяет упростить управление доступом, так как разрешения назначаются ролям, а не каждому пользователю индивидуально.

Текст также описывает создание перечисления ролей для проекта и добавление столбца "роль" в сущность пользователя. Предполагается, что роли могут быть, например, "обычный пользователь" и "администратор". Важно отметить, что в реальных проектах роли могут быть более сложными и динамическими, и их управление может потребовать базы данных и административной панели.

Текст также упоминает использование функции REPL (Read-Eval-Print Loop) для обновления ролей для существующих пользователей в базе данных. Это предназначено для удобства обучения и тестирования, и не является рекомендуемым способом управления данными в производственной среде.


## Claims-based Authorization

В данном тексте объясняется концепция авторизации на основе заявок (claims-based authorization) и различия между авторизацией и аутентификацией. Авторизация на основе заявок позволяет определять несколько разрешений и назначать их пользователям, вместо того чтобы определять набор ролей для пользователей. Это предоставляет более гибкий и детализированный контроль над доступом к ресурсам.

Авторизация на основе заявок полезна, когда требуется точный контроль над разрешениями пользователей. Например, разные пользователи могут иметь разные права на создание, обновление и удаление ресурсов. В тексте также указывается, что обычно разрешения хранятся в базе данных, и реальное приложение может использовать таблицу разрешений.

Для реализации авторизации на основе заявок, автор предлагает создать перечисление разрешений и добавить декораторы разрешений к методам, которые требуют определенных разрешений. Затем создается стража разрешений, которая проверяет, имеет ли пользователь все необходимые разрешения для доступа к определенной конечной точке.

Текст также уточняет, что на практике разрешения могут быть связаны с ролями или храниться в базе данных. Далее показывается, как добавить столбец "разрешения" к сущности пользователей и как включить это поле в токен доступа.

В конечном итоге текст демонстрирует, как назначать разрешения конкретному пользователю с использованием REPL (Read-Eval-Print Loop), и как проверять эти разрешения при доступе к определенным ресурсам.


## Policy-based Authorization

1.
Политика - это набор требований, которые пользователь должен выполнить, чтобы получить доступ к определенному ресурсу. В основе авторизации на основе политики лежат жестко заданные правила, которые определяют, кто и как может получить доступ к ресурсам. Это может быть полезно в более сложных сценариях авторизации, хотя в большинстве приложений обычно достаточно авторизации на основе ролей или заявок.

Для реализации авторизации на основе политики, вы создаете обработчики политики, которые определяют, как проверять выполнение политики. Каждая политика имеет свой собственный обработчик, и они могут быть настроены для разных частей вашего приложения.

Вы также можете создавать интерфейсы политики и обработчика политики, чтобы структурировать ваш код и упростить отладку. Эти интерфейсы описывают, какие методы и свойства должны быть у политики и её обработчика.

Общий паттерн использования включает создание структуры для хранения обработчиков политики, которая связывает политики с их обработчиками. При выполнении запроса к ресурсу вы определяете, какие политики должны быть проверены, и затем используете соответствующие обработчики для этой проверки.

Этот подход может быть полезен в сложных приложениях, где требуется гибкая система авторизации с разнообразными требованиями.

2.
В этом уроке рассматривается реализация настраиваемой политики для демонстрационных целей в Nest.js. Создается политика "участника фреймворка", которая проверяет, зарегистрирован ли адрес электронной почты пользователя в домене nestjs.com.

Для начала, внутри каталога политик создается файл "framework-contributor.policy.ts", в котором создается класс "FrameworkContributorPolicy", реализующий интерфейс политики. Политика просто проверяет домен адреса электронной почты пользователя и в случае неподходящего домена выбрасывает исключение.

Затем создается обработчик этой политики, который связывается с ней. Обработчик также реализует интерфейс и выполняет проверку политики.

Политика применяется с помощью декоратора "policies" к конечным точкам или контроллерам. Затем используется стража политики для выполнения проверки наличия политик для данной операции и их последующего выполнения.

Урок демонстрирует, как можно настраивать политику авторизации для конкретных требований приложения, а также как применять их к разным частям приложения в Nest.js.

## Introduction to API Keys

API-ключ – это уникальный идентификатор, используемый для взаимодействия с API или выполнения запросов к нему. Он может быть использован либо для анонимного доступа к публичным данным приложения, либо для создания вторичных учетных данных, которые позволяют отправлять запросы от имени конкретного пользователя.

В первом случае API-ключи удобны для доступа к общедоступным данным и для идентификации запросов, связанных с вашим проектом. Во втором случае API-ключи представляют собой вторичные учетные записи пользователей, которые имеют определенные права доступа, в зависимости от настроенных параметров.

Выбор между этими двумя вариантами зависит от типа вашего приложения. Например, для продукта SaaS, где пользователи создают собственные проекты, первый вариант, в котором API-ключи связаны с проектами, может быть более подходящим. В случае социальной сети или аналогичного приложения, второй вариант, позволяющий пользователям создавать собственные API-ключи для взаимодействия с вашим API, может быть более полезным.

Пользователи могут создавать API-ключи, которые позволяют им взаимодействовать с вашим API от имени сторонних инструментов. Эти ключи могут иметь определенные права и области доступа, управляемые пользователями.

Выбор между этими подходами зависит от потребностей вашего проекта. В следующих уроках будет рассмотрена реализация второго варианта, но первый подход также будет рассмотрен и может быть практически аналогичен в реализации.


## Integrate API Keys feature

1.
В этой главе мы реализуем функцию API-ключей для отправки запросов от имени пользователя. Начнем с создания класса сущности под названием API-key и поместим его в каталог users/API-keys/entities. Мы уберем суффикс "entity", добавим несколько столбцов (ID, key, UUID), и установим отношение многие-к-одному с сущностью пользователя.

Далее мы зарегистрируем сущность API-key в нашем приложении, обновив также сущность пользователя, чтобы указать, что пользователь - владелец отношения один-ко-многим с API-ключами.

Затем создадим новую службу API-keys в каталоге authentification и определим в ней четыре метода: createAndHash для создания и хеширования API-ключей, validate для проверки API-ключей, extractIdFromAPIKey для извлечения ID из API-ключа и generateAPIKey для генерации строк API-ключей.

Мы также объявим интерфейс payload для API-ключей, содержащий API-key (дружественный пользовательский API-ключ) и hashed-key (хешированная версия API-ключа), и внедрим службу хеширования в конструктор службы API-keys.

Метод generateAPIKey генерирует случайную уникальную строку API-ключа, добавляет префикс API-key и возвращает ее в формате base64. Метод createAndHash генерирует API-ключ и его хеш, а метод validate проверяет API-ключи. Метод extractIdFromAPIKey извлекает ID из закодированного API-ключа.

Затем создаем охранник API-ключа с использованием схемы Nest.js. В нем извлекаем объект запроса из контекста выполнения, определяем метод extractKeyFromHeader для извлечения API-ключа из заголовка авторизации. Мы также обновляем охранник токена доступа для поддержки этой проверки.

В методе canActivate охранника API-ключа мы извлекаем API-ключ и, если он не определен, вызываем исключение "unauthorized". Мы также внедряем службу API-key и репозиторий API-keys для проверки входящих API-ключей и получения записей API-ключей из базы данных. Используя метод extractIdFromAPIKey, извлекаем идентификатор API-ключа из закодированной строки.

2. 
В данном уроке мы добавляем обработку исключений с использованием блоков try-catch. В блоке try мы извлекаем сущность API-key из таблицы API-keys, используя извлеченный из закодированной строки ID. Мы также убеждаемся, что ORM автоматически заполняет связанную сущность пользователя в этом запросе.

Затем мы используем метод validate службы API-keys для проверки API-ключа и его хеша, который хранится в базе данных. Для разрешения использования API-ключей от имени конкретных пользователей мы также присваиваем связанную сущность пользователя объекту запроса.

Далее мы внедряем охранник API-ключа в охранник аутентификации и обновляем перечисление auth type enum, добавляя туда API-ключ.

Завершая настройку, мы регистрируем репозиторий API-key в контексте модуля IAM, чтобы он мог быть внедрен в охранник аутентификации.

Чтобы протестировать это, мы создаем тестовый API-ключ в REPL Nest.js. Затем мы обновляем заголовок авторизации в Insomnia, используя сгенерированный API-ключ, и отправляем запрос к точке доступа Coffee's. В результате мы успешно аутентифицируемся от имени пользователя и видим, что запрос выполнен успешно.

Теперь наша точка доступа Coffee's поддерживает как биржевые токены, так и аутентификацию на основе API-ключей, расширяя возможности нашего приложения.

## Google Authentication - NestJS portion

В этом уроке мы реализовали аутентификацию через Google в нашем приложении Nest. Мы начали с настройки переменных окружения для Google Client ID и Google Client Secret, полученных из Google Cloud Platform.

Затем мы установили библиотеку Google Auth и создали службу и контроллер для аутентификации через Google.

В службе мы инициализировали OAuthClient с использованием полученных Client ID и Client Secret, внедрили необходимые зависимости и реализовали метод authenticate, который обрабатывает полученный токен Google и выполняет аутентификацию пользователя.

Мы также обновили сущность пользователя, добавив столбец для Google ID и сделав пароль nullable, так как пользователи, использующие Google для входа, не имеют обычных паролей.

В контроллере мы создали маршрут authenticate, который вызывает метод аутентификации Google и аннотировали контроллер декоратором Auth с параметром AuthType.None, чтобы сделать маршрут общедоступным.

Мы также создали DTO google-token.dto и добавили CORS-настройки в файл main.ts.

Наконец, мы запустили React-приложение для тестирования аутентификации через Google и убедились, что процесс работает успешно.

Таким образом, мы интегрировали аутентификацию Google в наше приложение Nest, предоставляя пользователям удобную опцию для регистрации и входа в систему.


## Two-factor authentication

1.
Двухфакторная аутентификация (2FA) - это метод обеспечения безопасности, требующий от пользователей двойной проверки их личности перед получением доступа к системе. Этот процесс включает в себя ввод одноразового токена, который генерируется динамически и отправляется только пользователю, например, с помощью Google Authenticator или SMS. 2FA защищает от различных видов атак, таких как фишинг и перебор паролей, и является важной частью систем безопасной аутентификации.

В этом уроке мы рассмотрели настройку двухфакторной аутентификации в приложении NestJS. Мы установили необходимые зависимости, такие как OTPlib для генерации и проверки одноразовых паролей и QR-кодов для приложения Google Authenticator. Затем мы создали службу аутентификации OTP, в которой сгенерировали секретный ключ для каждого пользователя и создали URI для настройки Google Authenticator. Мы также добавили метод для проверки предоставленного пользователем кода.

Для поддержки двухфакторной аутентификации мы обновили сущность пользователя, добавив столбцы для включения 2FA и хранения секретного ключа.

Затем мы добавили конечную точку в контроллере аутентификации, которая возвращает QR-код для настройки Google Authenticator. Мы защитили этот маршрут 2FA, чтобы обеспечить безопасность доступа к нему.

Этот урок помог настроить двухфакторную аутентификацию в нашем приложении, предоставляя пользователям более высокий уровень безопасности и защиту от потенциальных атак.

2.
В этом уроке мы настроили двухфакторную аутентификацию (2FA) в нашем приложении. Начиная с создания QR-кода, предназначенного для приложения Google Authenticator, мы сгенерировали уникальный секрет для активного пользователя, включили 2FA, и в ответ на запрос отдали QR-код в виде изображения. Для этого мы использовали библиотеку OTPlib и QR-коды.

Затем мы обновили процесс входа в систему, требуя от пользователя также ввод TOTP (одноразового пароля на основе времени), полученного из приложения Google Authenticator. Мы модифицировали класс DTO для входа, добавив поле TFA code для передачи этого кода.

В службе аутентификации мы интегрировали службу аутентификации OTP, чтобы проверить TOTP код, если 2FA включена для данного пользователя. Теперь пользователи должны предоставить дополнительный код 2FA при входе, что повышает безопасность и защищает от несанкционированного доступа.

Этот урок помог настроить 2FA в нашем приложении и улучшил уровень безопасности при входе в систему.



## Sessions with Passport

1.
В этом уроке мы рассмотрели интеграцию библиотеки Passport с Nest.js для аутентификации в приложении. Passport - популярная библиотека аутентификации для Node.js с множеством стратегий. Мы узнали, что Nest.js Passport облегчает использование Passport в проектах Nest.js.

Вместо JWT-токенов для аутентификации, мы решили использовать серверные сессии, основанные на куки. Сессии позволяют хранить данные о текущем пользователе между запросами. Однако они могут столкнуться с проблемами при балансировке нагрузки и могут потребовать использования базы данных, такой как Redis, для хранения идентификаторов сессий.

Мы установили необходимые зависимости, включая Passport, @nestjs/passport и Express Session, а также добавили переменную окружения для секрета сессии.

Затем мы зарегистрировали функции промежуточного программного обеспечения Passport в модуле IAM и создали службу аутентификации сессии с соответствующим контроллером.

В службе аутентификации сессии мы реализовали метод sign-in, который позволяет пользователям аутентифицироваться и возвращает сущность пользователя вместо JWT-токенов.

Таким образом, этот урок демонстрирует, как интегрировать Passport для упрощения аутентификации в приложениях Nest.js и как использовать серверные сессии вместо JWT-токенов для аутентификации.

2.
В этом уроке мы рассмотрели интеграцию библиотеки Passport с Nest.js для аутентификации на основе сессий. Мы начали с создания контроллера аутентификации сессии и декорировали его, чтобы все его маршруты были общедоступными. Затем мы внедрили службу аутентификации сессии и добавили метод sign-in, который использует Passport для аутентификации пользователя.

Для правильной работы Passport требуется настройка сериализации и десериализации пользовательских данных. Мы создали класс UserSerializer, который расширяет PassportSerializer и определил методы serializeUser и deserializeUser для этой цели.

Далее мы создали SessionGuard, который проверяет, аутентифицирован ли текущий пользователь.

Мы также обсудили важные аспекты использования идентификаторов сессий, включая их хранение в памяти и рекомендацию использовать внешнюю базу данных, такую как Redis, для надежного сохранения сессий между перезапусками приложения.

В заключение, мы подчеркнули удобство использования библиотеки Passport для аутентификации в Nest.js и отметили, что с использованием JWT подходит для подобных целей и легко интегрируется с Nest.js.